# 前端知识点整合笔记

## 第一部分 包含[css2.1](#css21) ,[css3(层叠样式表)](#css3层叠样式表) ,[CSS预处理器less](#css预处理器less) ,[Bootstrap栅格系统&源码分析](#bootstrap栅格系统源码分析),[html5](#html5)

<!-- TOC -->

- [css2.1](#css21)            
	- [1.  三列布局(两边固定，当中自适应，当中列要完整且要优先加载)](#1--三列布局两边固定当中自适应当中列要完整且要优先加载)            
	- [2. 黏连布局(sticky Footer)](#2-黏连布局sticky-footer)            
	- [3. BFC](#3-bfc)        
- [css3(层叠样式表)](#css3层叠样式表)            
	- [1. 选择器](#1-选择器)            
	- [2. 自定义字体](#2-自定义字体)            
	- [3. 新增UI方案](#3-新增ui方案)            
	- [4. 过渡](#4-过渡)            
	- [5. 2D变换(transform)](#5-2d变换transform)            
	- [6. 3D变换](#6-3d变换)            
	- [7. 动画](#7-动画)            
	- [8. flex](#8-flex)                
	- [作用在flex容器上的CSS属性](#作用在flex容器上的css属性)         
	- [作用在flex子项上的CSS属性](#作用在flex子项上的css属性)
	- [其他Flex知识点](#其他flex知识点)            
	- [9. 媒体查询](#9-媒体查询)        
- [CSS预处理器less](#css预处理器less)        
- [Bootstrap栅格系统&源码分析](#bootstrap栅格系统源码分析)        
- [HTML5](#html5)
<!-- /TOC -->

---

## css2.1

**CSS:Cascading  style sheets**<br> 
[https://www.w3.org/TR/2011/REC-css3-selectors-20110929/](https://www.w3.org/TR/2011/REC-css3-selectors-20110929/ "CSS3选择器规范地址")<br>
[https://www.w3.org/TR/selectors](https://www.w3.org/TR/selectors "CSS3选择最新选择器规范")<br>
**[页面元素坐标和偏移整理](https://www.cnblogs.com/skylar/p/4121508.html "页面元素坐标和偏移整理")**<br>
**[flex布局笔记](https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/ "display: flex布局笔记")**<br>
**[flex练习游戏](http://flexboxfroggy.com/ "flex练习游戏")**<br>


#### 1.  三列布局(两边固定，当中自适应，当中列要完整且要优先加载)

*  <font color=red>**三列布局**</font>
		* 左边的div往左浮动，右边的div往右边浮动，中间的div宽度自适应  
*  <font color=red>**圣杯布局** </font>
		*  middle  开启浮动，让左右的div可以上来，宽高都为100%<br>
		   left	   开启浮动，margin-left:-100%，开启定位来调整left<br>
		   right   开启浮动，margin-left:-200px(此处的200px为左右div的宽度)，开启定位来调整right
*  <font color=red>**双飞燕布局**</font>(在圣杯布局的基础上，将middle作为一个包裹器包裹在inner外，将本来放在middle中的内容放在inner中，将padding给inner，这样就不用开启定位来调整left和right了）
		*  给left，right指定固定的宽度，middle的width: 100%;<br>
		   middle，left，right全部向左浮动(记得清楚浮动！解决高度塌陷问题)<br>
		   left中，margin-left:-100%<br>
		   right中，margin-left:-200px<br>
		   inner的padding:0 200px<br>
*  <font color=red>**伪等高布局**</font>
		*  padding-bottom: 10000px;<br>
		   margin-bottom: -10000px;<br>
		   包裹的div要overflow:hidden
*  <font color=red>**滚动条**</font>
		   <table >
				<tr>
					<td ></td>
					<td >overflow属性</td>
					<td >overflow属性</td>
					<td >overflow属性</td>
				</tr>
				<tr>
					<td >body</td>
					<td >写了(作用于body)</td>
					<td >没写</td>
					<td >写了</td>
				</tr>
				<tr>
					<td >html</td>
					<td >写了(作用于文档)</td>
					<td >写了</td>
					<td >没写</td>
				</tr>
				<tr>
					<td >滚动条出现在</td>
					<td >body,文档</td>
					<td >文档</td>
					<td >文档</td>
				</tr>
			</table>
*  <font color=red>**禁止滚动条**</font>
	*  只有拖动系统滚动条，初始包含块才会动,拖动body的滚动条，是不会使初始包含块移动的
	  		`html,body{
				height: 100%;
				overflow: hidden;
			}`
*  <font color=red>**使用绝对定位来模拟固定定位(移动端常用)**</font>
	*   IE6及以下不支持fixed<br>
			1. 禁止系统滚动条(在html和body里添加overflow:hidden)
			2. 将滚动条加给body
			3. 让body的尺寸变为视口的尺寸(height:100%)<br>
			`html{
      				overflow: hidden;
      				height: 100%;
      			}`<br>
    		`body{
      				overflow:   ;
      				height: 100%;
      			}`<br>
			html上的overflow属性作用给文档，body上的overflow属性作用给自己

#### 2. 黏连布局(sticky Footer)

	经典的"粘连"布局
	当我们有一块内容弄<main>
	当<main>的高度足够长的时候，<footer>应该紧跟在<main>元素的后面。
	当<main>元素比较短的时候(小于屏幕的高度)，我们期望这个<footer>元素能够"粘连"在屏幕的底部
		结构：
			<div id="wrap">
				<div class="main">
					main
				</div>	
			</div>
			<div id="footer">
				footer
			</div>
		实现方法(负margin)：
				1.  html，body的height为100%,wrap的min-height为100%
				2.  main中padding-bottom:50px
				3.	footer中margin-top:-50px
				4.	
#### 3. BFC

**block formating context块格式化上下文**<br>
*	<font color=red>**再解释BFC是什么之前，需要介绍Box Formatting Context的概念**</font><br>
		Box：CSS布局的基本单位
			Box是CSS布局的对象和基本单位，直观点来说就是一个页面是由很多个Box组成的。
			元素的类型和display属性，决定了这个Box的类型。不同类型的Box，会参与不同的Formatting Context(一个决定如何渲染文档的容器)
			因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：
				block-level box:
					display属性为block,list-item,table元素，会生成block-level box。并且参与block formating context(BFC)
				inline-level box:
					display属性为inline,inline-block,inline-table元素，会生成inline-level box。并且参与inline formating context(IFC)
	
		Formatting context
			Formatting context是W3C CSS2.1 规范中的一个概念。
			他是页面中的一块渲染区域，并且有一套渲染规则，他决定了其子元素将如何定位，以及和其他元素的关系和相互作用
			最常见的BFC和IFC

*  <font color=red>**BFC是什么**</font><br>
		BFC(block formating context)直译为“块级格式化上下文”。他是一个独立的渲染区域，只有block-level box参与
		它规定了内部的block-level box如何布局，并且与这个区域外部毫不相干
		
*  <font color=red>**BFC布局规则**</font><br>
		1.内部的Box会在垂直方向，一个接一个地放置
		2.BFC的区域不会与float box重叠
		3.内部的Box垂直方向的距离有margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠
		4.计算BFC的高度时，浮动元素也参与计算。(清除浮动 haslayout)
		5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此
	
*  <font color=red>**BFC什么时候出现(哪些元素会生成BFC)**</font><br>
		根元素
		float属性不为none
		position为absolute或fixed
		overflow不为visible
		display为inline-block,table-cell,table-caption,flex,inline-flex
*	<font color=red>**两列布局**</font>	<br>
	结构：
	`<div id="left">left</div>`<br>`<div id="right">right</div>`<br>
	`#left{
				width: 200px;
				background: pink;
				float: left;
			}`<br>
	`#right{
				background: deeppink;
				overflow: hidden;
			}`
*	<font color=red>**溢出显示省略号**</font>	<br>
	溢出显示省略号 四个条件缺一不可！！<br>
				`display: block; `<br>
				`white-space: nowrap;`<br>
				`text-overflow: ellipsis;`<br>
				`overflow: hidden;`<br>
*	<font color=red>**兄弟元素之间的margin重叠情况**</font>	<br>
		发生margin重叠需要满足的三个条件：属于同一个BFC的两个相邻Box的margin会发生重叠<br>
			解决方法：破坏任意一个条件即可<br>
				解决方法一 :在外面包一个开启BFC的div<br>
				解决方法二：加边框，使两个元素不相邻<br>
				解决方法三：把块元素改成inline元素<br>
*	<font color=red>**父子元素之间的margin重叠情况**</font>	<br>
		`<div id="wrap">`<br>
		`<!--解决方法一 :给wrap开启BFC-->`<br>
		`<!--解决方法二：加边框，使两个元素不相邻-->`<br>
			`<div id="inner"></div>`<br>
		`</div>`<br>
*	<font color=red>**清除浮动**</font>	<br>
	*	给父级加高度<br>
		扩展性不好
	
	*	开启BFC<br>
		overflow-hidden<br>
		定位<br>
		浮动<br>
		ie6 7底下不支持BFC<br>
	*	层级<br>
		a.浮动提升半层，只有在浮动的情况下，才需要考虑元素分两层<br>
			定位元素提一层<br>
				相对定位会在文档流你有残留<br>
		b.z-index为1怎么都会比a高;z-index为-1怎么都会比a低<br>
		
		
	*	br标签<br>
		ie6 不支持<br>
		违反了结构 行为 样式相分离的原则<br>
	
	*	空标签<br>
		违反了结构 行为 样式 相分离的原则<br>
			ie6下元素的最小高度为19px<br>
				可以尝试给元素的fontsize设为0----->2<br>
				
	*	伪元素+开启haslayout<br>
		因为ie6 7下不支持伪元素<br>
		所以要额外的去开启haslayout<br>
	<pre>
    <code>
        .clearfix{
		    *zoom:1;
		}
	    .clearfix:after{
		    content:"";
		    display:block;
		    clear:both;
		}
    </code>
	</pre>   
*	<font color=red>**垂直水平居中**</font>	<br>
	*	方案一：
		已知宽高的块级元素
	<pre>
    <code>
        position: absolute;
        left: 50%;
        top: 50%;
        margin-left: -50px;
        margin-top: -50px;
        width: 100px;
        height: 100px;
    </code>
	</pre>   

    *	方案二：
        利用绝对定位盒子的特性
        水平方向上：left + right + width + padding + margin = 包含块padding区域的尺寸
        垂直方向上：top + bottom + height + padding + margin = 包含块padding区域的尺寸
	<pre>
    <code>
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        margin:   ;
        width: 100px;
        height: 100px;
    </code>
	</pre>   
                
    *	方案三：
    	未知宽高的块级元素（使用translate3d）
	<pre>
    <code>
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate3d(-50%,-50%,0);
    </code>
	</pre> 
        
    *	方案四:
    	图片(使用基线，和伪元素)
	<pre>
    <code>
        #wrap img{
            vertical-align: middle;
        }
        #wrap:after{
            /*占位元素*/
            content: "";
            display: inline-block;
            height: 100%;
            width: 0;
            background: pink;
            vertical-align: middle;
        }
    </code>
	</pre> 

----

### css3(层叠样式表)

#### 1. 选择器

*	**样式表的组成:**<br>
		样式表由规则组成<br>
				规则由选择器和声明块组成<br>
					声明块由声明组成<br>
						声明由CSS属性+CSS属性值组成的键值对<br>
*	**浏览器渲染样式表的顺序**<br>
		*从右往左*<br>
*	**[http://www.ruanyifeng.com/blog/2009/03/css_selectors.html](http://www.ruanyifeng.com/blog/2009/03/css_selectors.html "CSS选择器笔记")**<br>
	这个博客中包括44个选择器，基本涵盖了CSS2和CSS3的所有规定<br>
	+ 基本选择器
	+ 多元素的组合选择器
	+ CSS 2.1 属性选择器
	+ CSS 2.1中的伪类
	+ CSS 2.1中的伪元素
	+ CSS 3的同级元素通用选择器
	+ CSS 3 属性选择器
	+ CSS 3中与用户界面有关的伪类
	+ CSS 3中的结构性伪类
	+ CSS 3的反选伪类
	+ CSS 3中的 :target 伪类

*	**css声明的优先级**
	+  **选择器的特殊性:**<br>
    选择器的特殊性由选择器本身的组件确定，特殊性值表述为4个部分，如    0,0,0,0<br>
	+  **一个选择器的具体特殊性如下确定**：<br>
			       1.对于选择器中给定的ID属性值，加 0,1,0,0<br>
			       2.对于选择器中给定的各个类属性，属性选择，或伪类，加 0,0,1,0<br>
			       3.对于选择器中的给定的各个元素和伪元素，加0,0,0,1<br>
			       4.通配符选择器的特殊性为0,0,0,0<br>
			       5.结合符对选择器特殊性没有一点贡献<br>
			       6.内联声明的特殊性都是1,0,0,0<br>
			       7.继承没有特殊性<br>
 
			特殊性 1,0,0,0 大于所有以0开头的特殊性(不进位)
			选择器的特殊性最终都会授予给其对应的声明<br>
			如果多个规则与同一个元素匹配，而且有些声明互相冲突时，特殊性越大的越占优势
 
				注意：id选择器和属性选择器
				      div[id="test"]（0,0,1,1） 和 #test（0,1,0,0）  
	+  **重要声明**<br>
			有时某个声明比较重要，超过了所有其他声明，css2.1就称之为重要声明<br>
			并允许在这些声明的结束分号之前插入  !important  来标志<br>
			必须要准确的放置  !important 否则声明无效。 <br>
			!important 总是要放在声明的最后，即分号的前面<br>
			 
			 标志为 !important的声明并没有特殊的特殊性值，不过要与非重要声明分开考虑。<br>
			 实际上所有的重要声明会被浏览器分为一组，重要声明的冲突会在其内部解决<br>
			 非重要声明也会被分为一组，非重要声明的冲突也会在其内部解决<br>
			 如果一个重要声明与非重要声明冲突，胜出的总是重要声明<br>
	+  **继承**<br>
			继承没有特殊性，甚至连0特殊性都没有<br>
			0特殊性要比无特殊性来的强<br>
	+  **来源**<br>
			css样式的来源大致有三种<br>
			  创作人员<br>
			  读者<br>
			  用户代理  <br> 
			 
	+  **权重**：<br>
			   读者的重要声明<br>
			   创作人员的重要声明<br>
			   创作人员的正常声明<br>
			   读者的正常声明<br>
			   用户代理的声明<br>
	+  **层叠**<br>
	+  **如何计算？**
			1.找出所有相关的规则，这些规则都包含一个选择器<br>
		    2.计算声明的优先级<br>
		               先按来源排序<br>
		               在按选择器的特殊性排序<br>
		               最终按顺序<br>
#### 2. 自定义字体
	自定义字体
		@font-face
		字体图标
			1.制作一套矢量图
			2.将矢量图与字符进行绑定
			3.使用工具或者站点生成一套字体
			4.最终使用
		 字体兼容处理网站
	       https://www.fontsquirrel.com/tools/webfont-generator
	    icomoon字体图标
	       https://icomoon.io/#home

#### 3. 新增UI方案
*	**文本新增样式**
	+	**opacity**
	+	**rgba**
	+	**文本阴影(实现浮雕文字，文字模糊)**<br>
			length(x轴的偏移量)<br>
			length(y轴的偏移量)<br>
			length(模糊程度)<br>
			color(阴影颜色)<br>
		`text-shadow:10px 10px 10px gray,pink 20px 20px 20px;`
	+	**高斯模糊（模糊背景）**
		`filter: blur(10px)`
	+	**文字描边（webkit内核  文字描边  背景镂空）**
		`-webkit-text-stroke:pink 4px;`
	+	**文字排版**<br>
		unicode-bidi 属性，和 direction 属性，决定如何处理文档中的双书写方向文本<br>
		`direction:rtl;
		unicode-bidi:bidi-override;`
	+	**[溢出显示省略号](####3.BFC)**
*	**盒模型新增样式**
	*	**盒模型阴影**<br>
			关键字(内 外阴影)<br>
			length(x轴的偏移量)<br>
			length(y轴的偏移量)<br>
			length(模糊程度)<br>
			length(阴影面积)<br>
			color(阴影颜色)<br>
		`box-shadow: -10px -10px 10px 0px black , 20px 20px 10px -10px deeppink;`
	*	**倒影（webkit内核  文字描边  背景镂空）**
		`-webkit-box-reflect:left 10px;`
	*	**resize**<br>
		允许你控制一个元素的可调整大小性<br>
		`resize :horizontal;`
	*	**box-sizing**
		定义了应该如何计算一个元素的总宽度和总高度<br>
		border-box：代表元素上设置的width和height表示的是border-box尺寸<br>
		content-box：代表元素上设置的width和height表示的是content-box尺寸<br>
		`box-sizing: border-box;`
*	**新增UI样式**
	*	**渐变**<br>
		*	**线性渐变**<br>
		`background-image:linear-gradient(90deg,red 10%,yellow 20%,green 30%) ;`<br>
		*	**纯色:**<br>`background-image:linear-gradient(90deg,rgba(0,0,0,1) 100px,rgba(0,0,0,1) 300px) ;`<br>
		*	**重复的渐变:**<br>`background-image:repeating-linear-gradient(90deg,rgba(0,0,0,0),rgba(0,0,0,1) 300px) ;`<br>
		
		*	**实现发廊灯**
		*	**实现光斑动画**
		*	**径向渐变**
			`background-image:radial-gradient( closest-corner circle at 20px 20px,yellow, green 50%,pink) ;`
	*	**border-radius(圆角)**
	*	**利用border-box实现风车**
	*	**利用伪元素实现对话框**
	*	**边框图片**
	*	**背景图片**
		*	**css2**
			*	**background-color**	平铺整个border-box<br>
			*	**background-image**	默认从padding-box开始绘制，从border-box开始剪裁,css3中有多背景，默认绘制时尺寸是自己的位图像素<br>
			*	**background-repeat**  控制平铺与否<br>
			*	**background-position**  控制背景图片在背景区域中的位置<br>
			百分比:参照于背景区域减去背景图片的位图像素值<br>
			*	**background-attachment**<br>
								scroll：默认值，背景图不会随着元素滚动条的滚动而滚动<br>
								fixed：背景图铺在视口中固定定位了<br>
		*	**css3**<br>
			*	background-origin<br>
			*	background-clip<br>
				clip 属性是定义元素可见区域的属性。<br>默认情况下背景图片是从padding box开始绘制,从border box开始剪裁	
			*	background-size <br>
				图片是自适应的<br>
	*	**带渐变的倒影（webkit内核  文字描边  背景镂空）**<br>
		`-webkit-box-reflect:right 0px linear-gradient(-90deg,rgba(0,0,0,.8) , rgba(0,0,0,0));`
#### 4. 过渡
*	**过渡的三个坑！！**
	*	a.过渡只关系元素的初始状态和结束状态，没有方法可以获取元素在过渡中每一帧的状态
	*	b.元素在初次渲染还没有结束的时候，是没有办法触发过渡的
	*	c.在绝大部分变换样式的切换时，变换组合的个数或位置不一样时，是没有办法触发过渡的
*	**transition-property** <br>
			指定过渡动画的属性（并不是所有的属性都可以动画）
*	**transition-duration**<br>
			指定过渡动画的时间（0也要带单位）
*	**transition-timing-function**<br>
			指定过渡动画的形式（贝塞尔曲线）
*	**ransition-delay**<br>
			指定过渡动画的延迟
*	**transition**<br>
			第一个可以被解析成时间的值会赋给transition-duration
*	**transtionend事件（DOM2）**<br>
			在每个属性完成过渡时都会触发这个事件
		当属性值的列表长度不一致时
			跟时间有关的重复列表
			transition-timing-function使用默认值
	`transition-property: background,width,height;`<br>
				`transition-duration: 1s,0s,1s;`<br>
	`transition-timing-function: linear;`<br>
				`transition-delay:3s;`<br>
*	**简写属性:**<br>
	`transition: all 1s ease-out;`<br>
	`transition: margin-right 2s, color 1s;`<br>
	transition: margin-right 2s .5s;`<br>
	
#### 5. 2D变换(transform)
*	**transform只能使用在块级元素上！！！**
*	**rotate**
			旋转
*	**translate**
			平移
*	**skew**
			斜切
*	**scale**
			缩放
*	**变换组合!**<br>
	*	顺序是从右往左的，变换的底层其实就是矩阵的运算
		`transform: scale(.5) translateX(100px);`
		可以理解为先自己以及坐标轴缩小了0.5倍，然后再向右移动100*0.5px
*	**基点的变换**<br>
			`transform-origin:center 100px;`
			px参照于正中间
*	**角度转弧度**<br>
			deg*PI/180
*	**实现扇形导航**
*	**实现按钮高亮**
*	**实现时钟**
#### 6. 3D变换
*	**transform只能使用在块级元素上！！！**
*	**3D旋转**
	*	**rotate3d(x, y, z, a)**
		*	x,y,x可以是0到1之间的数值，分别表示旋转轴X,Y,Z坐标方向的矢量。
		*	**`transform: rotate3d(1, 1, 1, 45deg);`**
*	**3D平移**
	*	**translate3d(tx, ty, tz)**
		*	tx,ty,tz分别代表移动向量的横坐标,纵坐标,z轴坐标。
		*	**`transform: translate3d(-50%,-50%,-100px);`**
*	**3D缩放**
	*	
	*	**`transform: translateZ(200px);`**,百分比的参照物是自己
*	**景深**
	*	让3D场景有近大远小的效果（我们肉眼距离屏幕的距离）,是一个不可继承属性，但他可以作用于后代元素（不是作用于本身的）,景深的基点是视角的位置
	*	有2种写法
		*	css属性
		*	transform属性的一个变换函数（必须在第一位）
	*	景深越大 灭点越远 元素变形更小,景深越小 灭点越近 元素变形更大
	*	需要尽量避免景深叠加
	*	**`perspective: 500px;`**
*	**transform-style**
	*	营造有层级的3d舞台,是一个不可继承属性，他作用于子元素
	*	**`transform-style: preserve-3d;`**
*	**隐藏元素背面**
	*	一个元素分两面，但并不意味元素有厚度。在一个状态下，元素只能展现自己的一面	
	*	**`backface-visibility:hidden`**
*	实现多棱柱
#### 7. 动画
*	**动画内的属性**
	*	**关键帧的名字**
		*	`animation-name: move;`
	*	**作用于一个关键帧周期而非整个动画周期**
		*	`animation-timing-function: linear;`
	*	**一个动画周期的时长**
		*	`animation-duration:3s ;`
*	**动画外的属性**
	*	**代表动画的延迟**
		*	`animation-delay:2s;`
*	**动画是否反向播放**
	*	`animation-direction:normal;`
	*	改变关键帧的执行方向，还会影响animation-timing-function的形式
*	**动画在结束前运行的次数，可以是infinite**
	*	`animation-iteration-count: 3;`
	*	**只作用于动画内的属性,重复的是关键帧**
*	**管理所有动画外的状态(动画外的状态即from之前,to之后)**
	*	`animation-fill-mode：forwards`
	*	**元素在动画外的状态有**
		*	backwards：from之前的状态与form的状态保持一致
		*	forwards：to之后的状态与to的状态保持一致
		*	botn：backwards+forwards
		*	none: 动画外的状态保持在动画之前的位置
*	**动画是否运行或者暂停**
	*	`animation-play-state: running;`
	*	定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。
*	**关键帧**
	<pre>
	<code>
	@keyframes animiationName{
	     keyframes-selector{
	          css-style;
	     }
    }
	keyframes-selector可以是关键帧form（0%）和to（100%）
	可以是百分比,代表的是时间的百分比（时间点） 	
	</code>
	</pre>		
*	**steps(num,[start/end])**
	*	num:拆成多少步（当num为12时，整个动画最好有13帧）
	*	start：看不见第一帧
	*	end：看不见最后一帧			
#### 8. flex

**[flex布局笔记](https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/ "display: flex布局笔记")**<br>
**[flex练习游戏](http://flexboxfroggy.com/ "flex练习游戏")**<br>
##### 作用在flex容器上的CSS属性

-	 **flex-direction**
		-	row
			-	 从左往右
		-	 row-reverse
				-	 从右往左
		-	 column
				-	 从上往下
		-	 column-reverse
				-	 从下往上
*	**flex-wrap**
	*	用来控制子项整体单行显示还是换行显示,，如果换行，则下面一行是否反方向显示。
	*	**nowrap**
		*	不换行
		*	flex子项最小内容宽度min-content之和大于flex容器宽度，则内容溢出，表现和white-space:nowrap类似。
		*	如果flex子项最小内容宽度min-content之和小于flex容器宽度，则：
			*	flex子项默认的fit-content宽度之和大于flex容器宽度，则flex子项宽度收缩，正好填满flex容器，内容不溢出。
			*	flex子项默认的fit-content宽度之和小于flex容器宽度，则flex子项以fit-content宽度正常显示，内容不溢出。
		*	例子：图片默认有设置max-width:100%，flex子项div没有设置宽度，因此，flex子项最小宽度是无限小，表现为图片宽度收缩显示。如果取消max-width:100%样式，则此时flex子项最小宽度就是图片宽度，图片溢出到了flex容器之外。
	*	**wrap**
		*	宽度不足换行显示。从上往下
	*	**wrap-reverse**
		*	宽度不足换行显示，从下往上
*	**flex-flow**
	*	是flex-direction和flex-wrap的缩写
	*	`flex-flow: row-reverse wrap-reverse;`
*	**justify-content**
	*	决定了水平方向子项的对齐和分布方式
	*	**flex-start**
		*	默认值，左对齐
	*	**flex-end**
		*	右对齐
	*	**center**
		*	居中对齐
	*	**space-between**
		*	两端对齐
	*	**space-around**
		*	around是环绕的意思，意思是每个flex子项两侧都环绕互不干扰的等宽的空白间距，最终视觉上边缘两侧的空白只有中间空白宽度一半。
	*	**space-evenly**
		*	evenly是匀称、平等的意思。也就是视觉上，每个flex子项两侧空白间距完全相等
	*	justify-content可以看成是text-align的远房亲戚，不过前者控制flex元素的水平对齐外加分布，后者控制内联元素的水平对齐。
*	**align-items**
	*	items指的就是flex子项们，align-items指的就是flex子项们相对于flex容器在垂直方向上的对齐方式
	*	**stretch**
		*	默认值。flex子项高度拉伸到容器高度，如果flex子项设置了高度，则按照设置的高度值渲染，而非拉伸。
	*	**flex-start**
		*	容器顶部对齐
	*	**flex-end**
		*	容器底部对齐
	*	**center**
		*	垂直居中对齐
	*	**baseline**
		*	所有flex子项都相对于flex容器的基线(内敛元素的下边缘)对齐
*	**align-content**
	*	align-content则是指明垂直方向每一行flex元素的对齐和分布方式，justify-content指明水平方向flex子项的对齐和分布方式，align-content可以看成和justify-content是相似且对立的属性，
	*	**stretch**
		*	默认值。每一行flex子元素都等比例拉伸。例如，如果共两行flex子元素，则每一行拉伸高度是50%。
	*	**flex-start**
		*	顶部堆砌
	*	**flex-end**
		*	底部堆放
	*	**center**
		*	垂直居中对齐
	*	**space-between**
		*	上下两行两端对齐。剩下每一行元素等分剩余空间
	*	**space-around**
		*	每一行元素上下都享有独立不重叠的空白空间
	*	**space-evenly**
		*	每一行元素都完全上下等分
##### 作用在flex子项上的CSS属性
*	**order**
	*	通过设置order改变某一个flex子项的排序位置
	*	所有flex子项的默认order属性值是0，因此，如果我们想要某一个flex子项在最前面显示，可以设置比0小的整数，如-1就可以了。
*	**flex-grow**
	*	grow是扩展的意思，，扩展的就是flex子项所占据的宽度，扩展所侵占的空间就是除去元素外的剩余的空白间隙。
	*	flex-grow不支持负值，默认值是0，表示不占用剩余的空白间隙扩展自己的宽度，如果flex-grow大于0，则flex容器剩余空间的分配就会发生，具体规则如下：
		*	**所有剩余空间总量是1。**<br>
		*	**如果只有一个flex子项设置了flex-grow属性值**：<br>
			*	如果flex-grow值小于1，则扩展的空间就总剩余空间和这个比例的计算值。<br>
			*	如果flex-grow值大于1，则独享所有剩余空间。<br>
		*	**如果有多个flex设置了flex-grow属性值：**
			*	如果flex-grow值总和小于1，则每个子项扩展的空间就总剩余空间和当前元素设置的flex-grow比例的计算值。
			*	*如果flex-grow值总和大于1，则所有剩余空间被利用，分配比例就是flex-grow属性值的比例。例如所有的flex子项都设置flex-grow:1，则表示剩余空白间隙大家等分，如果设置的flex-grow比例是1:2:1，则中间的flex子项占据一半的空白间隙，剩下的前后两个元素等分。
*	**flex-shrink**
	*	shrink是“收缩”的意思，flex-shrink主要处理当flex容器空间不足时候，单个元素的收缩比例。
	*	flex-shrink不支持负值，默认值是1，也就是默认所有的flex子项都会收缩。如果设置为0，则表示不收缩，保持原始的fit-content宽度。
	*	**已知flex子项不换行，且容器空间不足，不足的空间就是“完全收缩的尺寸”:**
		*	如果只有一个flex子项设置了flex-shrink：
			*	flex-shrink值小于1，则收缩的尺寸不完全，会有一部分内容溢出flex容器。
			*	flex-shrink值大于等于1，则收缩完全，正好填满flex容器。
		*	如果多个flex子项设置了flex-shrink：
			*	flex-shrink值的总和小于1，则收缩的尺寸不完全，每个元素收缩尺寸占“完全收缩的尺寸”的比例就是设置的flex-shrink的值。
			*	flex-shrink值的总和大于1，则收缩完全，每个元素收缩尺寸的比例和flex-shrink值的比例一样。
*	**flex-basis**
	*	定义了在分配剩余空间之前元素的默认大小。相当于对浏览器提前告知：浏览器兄，我要占据这么大的空间，提前帮我预留好。
	*	默认值是  ，就是自动。有设置width则占据空间就是width，没有设置就按内容宽度来
	*	如果同时设置width和flex-basis，就渲染表现来看，会忽略width。flex顾名思义就是弹性的意思，因此，实际上不建议对flex子项使用width属性，因为不够弹性。
	*	当剩余空间不足的时候，flex子项的实际宽度并通常不是设置的flex-basis尺寸，因为flex布局剩余空间不足的时候默认会收缩。
*	**flex**
	*	**flex属性是flex-grow，flex-shrink和flex-basis的缩写。**
	*	flex:1相当于：<br>
			`flex-shrink: 1;`<br>
			`flex-grow: 1;`<br>
			`flex-basis: 0;`<br>
*	**align-self**
	*	align-self指控制单独某一个flex子项的垂直对齐方式，写在flex容器上的这个align-items属性，后面是items，有个s，表示子项们，是全体；这里是self，单独一个个体。其他区别不大，语法几乎一样：

##### 其他Flex知识点

*	在Flex布局中，flex子元素的设置float，clear以及vertical-align属性都是没有用的。
*	**Flexbox布局最适合应用程序的组件和小规模布局（一维布局），而Grid布局则适用于更大规模的布局（二维布局）**
*	已经8102年了，Flex老语法不用在管了，舒爽弃之，然后私有前缀也不用再加了

#### 9. 媒体查询

*	**css3媒体查询是响应式方案核心**
*	**媒体类型**
	*	all              所有媒体（默认值）
	*	screen           彩色屏幕
	*	print            打印预览	   
	*	projection       手持设备
	*	tv               电视
    *	braille          盲文触觉设备
    *	embossed     	 盲文打印机
    *	speech        	 “听觉”类似的媒体设备
    *	tty              不适用像素的设备
*	**媒体属性**
	*	width			   （可加max min前缀）
	*	height			   （可加max min前缀）
	*	device-width	   （可加max min前缀）
	*	device-pixel-ratio（可加max min前缀，需要加webkit前缀）
	*	orientation   portrait竖屏  landscape横屏
*	**操作符，关键字 (only,and,(，or),not)**
	*	**only：**
		*	防止老旧的浏览器  不支持带媒体属性的查询而应用到给定的样式.
	   	*	
	   			@media only screen and (min-width:800px ){
	   				规则；
	   				规则
	   			}
	   			@media  screen and (min-width:800px ){
	   				规则；
	   				规则
	   			}
	    *	在老款的浏览器下
	   		*	@media only    --->    因为没有only这种设备 规则被忽略
	   		*	@media screen --->   因为有screen这种设备而且老浏览器会忽略带媒体属性的查询
	   			
	   		*	建议在每次抒写media query的时候带上only
	   	
	*	**and:**
	   			连接媒体属性 、连接媒体类型
	   			对于所有的连接选项都要匹配成功才能应用规则
	   		
	*	**or(,) : 和and相似**
	   			对于所有的连接选项只要匹配成功一个就能应用规则
	   		
	*	**not:取反**
----

### CSS预处理器less
*	**less是一种动态样式语言，属于css预处理器的范畴，它扩展了 CSS 语言，**
	增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展
	**LESS 既可以在 客户端 上运行 ，也可以借助Node.js在服务端运行。**
*	**注释**
	*	以//开头的注释，不会被编译到css文件中
   	*	以/**/包裹的注释会被编译到css文件中  
*	**变量**
	*	**使用@声明变量**
		*	作为普通属性值只来使用：直接使用@pink
		*	作为选择器和属性名：#@{selector的值}的形式
		*	作为URL：@{url}
	<pre>
	<code>
	@color:deeppink;
	@m:margin;
	@selector:#wrap;
	*{
	    @{m}: 0;
	    padding: 0;
	}
	@{selector}{
	    position: relative;
	    width: 300px;
	    height: 400px;
	    border: 1px solid;
	    margin: 0   ;
	    .inner{
	        position: absolute;
	        left: 0;
	        right: 0;
	        top: 0;
	        bottom: 0;
	        margin:   ;
	        background: @color;
	        height: 100px;
	        width: 100px;
	    }
	}
	</code>
	</pre>
	*	**变量是块级作用域**
	*	**变量的延迟加载:**
	<pre>
	<code>
	@var: 0;
	.class {
		@var: 1;
    	.brass {
    		@var: 2;
     		three: @var;//3,他会等当前作用域所有东西解析完再来看@var是谁
      		@var: 3;
    	}
  		one: @var;  //1
	}
	</pre>
	</code>
*	**less中的嵌套规则**
	*	基本嵌套规则
	*	&的使用
		*	**&:平级**
	<pre>
	<code>
	#wrap{
	    position: relative;
	    width: 300px;
	    height: 400px;
	    .inner{
	        position: absolute;
	        left: 0;
	        right: 0;
	        top: 0;
	        bottom: 0;
	        margin:   ;
	        height: 100px;
	        width: 100px;
 		//$代表#wrap .inner
	        &:hover{
	            background: pink;
	        }
	    }
	}
	</pre>
	</code>
*	**混合 mixin**
	*	混合就是将一系列属性从一个规则集引入到另一个规则集的方式（相当于ctrl c+ctrl v）
	*	使用**.**的形式来定义
		*	普通混合(会编译到原生css中的）
		*	不会输出(不会编译到原生css中的）的混合（加双括号）
		*	带参数的混合
		*	带参数并且有默认值的混合
		*	带多个参数的混合
		*	命名参数
		*	匹配模式
			*	
		*	arguments变量

			<pre>
			<code>
			.border(@w,@style,@c){
		    	border: @arguments;
			}
			</pre>
			</code>

	<pre>
	<code>
	.juzhong(@w:10px,@h:10px,@c:pink){
	    background: @c;
	    height: @h;
	    width: @w;
	}
	#wrap{
    position: relative;
    width: 300px;
    height: 400px;
    border: 1px solid;
    margin: 0   ;
	    .inner{
	       .juzhong(100px ,100px,pink);
	    }
	    .inner2{
	       .juzhong();//有默认值
		   .juzhong(@c:black);//命名参数,在传形参的时候指定值
	    }
	}
	</pre>
	</code>
*	**计算**
	*	在less中可以进行加减乘除的运算
	<pre>
	<code>
	@rem:100rem;
	#wrap .sjx{
	   width:(100 + @rem)//200rem，计算双方只需要一方带单位即可
	}
	</pre>
	</code>
*	**继承**
	<pre>
	<code>
	#test{
			&:extend(.father)
	}
	#test:extend(.father){
			
	}
	继承实质上将.father选择器和#test组合成一个选择器，声明块使用.father的
	</code>
	</pre>
	*	性能比混合高
	*	灵活度比混合低
*	**避免编译**
	*	**使用~**
	*	` padding: ~"cacl(100px + 100)";`
---

### Bootstrap栅格系统&源码分析
- **grid.less(bootstrap的入口)**
	- **固体容器**
	<pre>
	<code>
	.container {
		.container-fixed();//调用mixin文件夹下的grid.less混合,定义了固体容器和流体容器的公共样式
		@media (min-width: @screen-sm-min) {
			width: @container-sm;
		}
		@media (min-width: @screen-md-min) {
			width: @container-md;
		}
		@media (min-width: @screen-lg-min) {
			width: @container-lg;
		}
	}
	</code>
	</pre>
	
	- **流体容器**
	<pre>
	<code>
	.container-fluid {
		.container-fixed();//同固体容器，调用mixin文件夹下的grid.less混合,定义了固体容器和流体容器的公共样式
	}
	</code>
	</pre>
	- **行**
	<pre>
	<code>
	.row {
		.make-row();//同固体，流体容器，调用mixin文件夹下的grid.less混合
	}
	</code>
	</pre>
	- **列**
	<pre>
	<code>
	.make-grid-columns();//调用mixin文件夹下的grid-framework.less
	</code>
	</pre>
	- **移动端优先**
	<pre>
	<code>
	// 移动优先	
	.make-grid(xs);
	@media (min-width: @screen-sm-min) {
	.make-grid(sm);
	}
	@media (min-width: @screen-md-min) {
	.make-grid(md);
	}
	@media (min-width: @screen-lg-min) {
	.make-grid(lg);
	}
	</code>
	</pre>

- **variables.less**
	- 存放变量
-	**mixin文件夹中**
	-	grid.less
		- **固体和流体容器的公共样式(.container-fixed 有15px的padding)**
		<pre>
		<code>
		// 固定和流体容器的公共样式
		//@grid-gutter-widt：槽宽(30px)
		.container-fixed(@gutter: @grid-gutter-width) {
			margin-right: auto;
			margin-left: auto;
			padding-left:  floor((@gutter / 2));//向上取整,槽宽的一半
			padding-right: ceil((@gutter / 2));//向下取整,槽宽的一半
			&:extend(.clearfix all);//清除浮动
		}
		</pre>
		</code>
		- **行(.make-row  有-15px的margin)**
		<pre>
		<code>
		.make-row(@gutter: @grid-gutter-width) {
			margin-left:  ceil((@gutter / -2));//负的槽宽的一半
			margin-right: floor((@gutter / -2));//负的槽宽的一半
			&:extend(.clearfix all);//清除浮动
		}
		</code>
		</pre>

		- **grid-framework.less(整个文件都是用来定义列的)**
			- 第一步：(为每个列加15px的padding)
			<code>
			<pre>
			// 列第一步
			.make-grid-columns() {
			//.col(2,".col-xs-1, .col-sm-1, .col-md-1, .col-lg-1")
			.col(@index) { 
				@item: ~".col-xs-@{index}, .col-sm-@{index}, .col-md-@{index}, .col-lg-@{index}";
				.col((@index + 1), @item);
			}
				/*  递归
					.col(3,".col-xs-1, .col-sm-1, .col-md-1, .col-lg-1,.col-xs-2, .col-sm-2, .col-md-2, .col-lg-2")
						....
					.col(13,str)
						str:
							.col-xs-1, .col-sm-1, .col-md-1, .col-lg-1,
							.col-xs-2, .col-sm-2, .col-md-2, .col-lg-2,
							...
							.col-xs-12, .col-sm-12, .col-md-12, .col-lg-12
				*/
			.col(@index, @list) when (@index =< @grid-columns) { 
				@item: ~".col-xs-@{index}, .col-sm-@{index}, .col-md-@{index}, .col-lg-@{index}";
				.col((@index + 1), ~"@{list}, @{item}");//递归
			}
				/*
					.col-xs-1, .col-sm-1, .col-md-1, .col-lg-1,
					.col-xs-2, .col-sm-2, .col-md-2, .col-lg-2,
					...
					.col-xs-12, .col-sm-12, .col-md-12, .col-lg-12{
					position: relative;
					min-height: 1px;
					padding-left: 15px;
					padding-right: 15px;
					}
				*/
			.col(@index, @list) when (@index > @grid-columns) {
				@{list} {//把最终递归完成获得的变量当做选择器来用
				position: relative;
				min-height: 1px;
				padding-left:  ceil((@grid-gutter-width / 2));
				padding-right: floor((@grid-gutter-width / 2));
				}
			}
			.col(1); 
			}
				</code>
				</pre>
			- 第二步：
			<pre>
			<code>
			// 列第二步
				.make-grid(@class) {
					//2.1
					.float-grid-columns(@class);//向左浮动
					//2.2
					.loop-grid-columns(@grid-columns, @class, width);//根据所占的列数为columns分配width
					//2.3(列排序)
					.loop-grid-columns(@grid-columns, @class, pull);//根据所占的列数为columns分配left
					.loop-grid-columns(@grid-columns, @class, push);//根据所占的列数为columns分配right
					//2.4(列偏移)
					.loop-grid-columns(@grid-columns, @class, offset);//根据所占的列数为columns分配margin
				}
				//2.1
				/*
				* .col-xs-1,.col-xs-2,.col-xs-3,.col-xs-4,...col-xs-12{
				*     float: left;
				* }
				* */
				.float-grid-columns(@class) {
				.col(@index) { 
					@item: ~".col-@{class}-@{index}";
					.col((@index + 1), @item);
				}
				.col(@index, @list) when (@index =< @grid-columns) { // general
					@item: ~".col-@{class}-@{index}";
					.col((@index + 1), ~"@{list}, @{item}");
				}
				.col(@index, @list) when (@index > @grid-columns) { // terminal
					@{list} {
					float: left;
					}
				}
				.col(1); 
				}
				//2.2（width） 2.3（pull push） 2.4（offset）的入口
				.loop-grid-columns(@index, @class, @type) when (@index >= 0) {
					.calc-grid-column(@index, @class, @type);
					.loop-grid-columns((@index - 1), @class, @type);
				}
				// 2.2
				/*
				* .col-xs-12{
				*     width:12/12;
				* }
				* .col-xs-11{
				*     width:11/12;
				* }
				* ...
				* .col-xs-1{
				*     width:1/12;
				* } 
				* */
				.calc-grid-column(@index, @class, @type) when (@type = width) and (@index > 0) {
					.col-@{class}-@{index} {
						width: percentage((@index / @grid-columns));
					}
				}
				//2.3
				/*push                  pull:
				* .col-xs-push-12{         .col-xs-pull-12{      
				*     left:12/12;              right:12/12;
				* }                        }
				* .col-xs-push-11{
				*     left:11/12;
				* }
				* ...                      ...
				* .col-xs-push-1{
				*     left:1/12;
				* } 
				* .col-xs-push-0{           .col-xs-pull-0{
				*     left:auto;               right:auto;
				* }                         }
				* */
				.calc-grid-column(@index, @class, @type) when (@type = push) and (@index > 0) {
					.col-@{class}-push-@{index} {
						left: percentage((@index / @grid-columns));
					}
				}
				.calc-grid-column(@index, @class, @type) when (@type = push) and (@index = 0) {
					.col-@{class}-push-0 {
						left: auto;
					}
				}
				.calc-grid-column(@index, @class, @type) when (@type = pull) and (@index > 0) {
					.col-@{class}-pull-@{index} {
						right: percentage((@index / @grid-columns));
					}
				}
				.calc-grid-column(@index, @class, @type) when (@type = pull) and (@index = 0) {
					.col-@{class}-pull-0 {
						right: auto;
					}
				}
				//2.4
				/*
				* .col-xs-offset-12{
				*     margin-left:12/12;
				* }
				* .col-xs-offset-11{
				*     margin-left:11/12;
				* }
				* ...
				* .col-xs-offset-1{
				*     margin-left:1/12;
				* } 
				* .col-xs-offset-0{
				*     margin-left:0;
				* } 
				* */
				.calc-grid-column(@index, @class, @type) when (@type = offset) {
					.col-@{class}-offset-@{index} {
						margin-left: percentage((@index / @grid-columns));
					}
				}
				</code>
				</pre>
	- **clearfix.less**
		<pre>
		<code>
		.clearfix() {//清除浮动
			&:before,
			&:after {
				content: " "; // 1
				display: table; // 2
			}
			&:after {
				clear: both;
			}
		}
		</pre>
		</code>



- 简洁、直观、强悍的前端开发框架，让web开发更迅速、简单
	- 中文网 ： http://www.bootcss.com/
	- 英文网  :  http://getbootstrap.com/
- **容器**
	- 流体布局容器
		-  容器的width为\n，只是两边加了15px的padding。
	- 固定布局
		- 容器的width会随设备分辨率的不同而生产变化
			- 分辨率阈值
			<pre>
			<code>
			w >=1200	 	容器的width为1170   左右padding为15 （注意是borderBox）
			1200>w >=992		容器的width为970     左右padding为15 （注意是borderBox）
			992 > w >=768		容器的width为750     左右padding为15  （注意是borderBox）
			768 > w >=992		容器的width为\n    左右padding为15  （注意是borderBox）
			</code>
			</pre>
			- 行
				- 两侧-15px margin
			- 列的公共样式
				- 两侧有15px 的padding
				- 相对定位
- **栅格系统**
	- col-lg-x    
	- col-md-x
	- col-sm-x
	- col-xs-x
	- x默认拥有12个等级
-	**列偏移**
	- 调整的是margin-left，分13个等级（0到12）
			0时为0%
- **列排序**
	- push的时候调整的是left，分13个等级（0到12）
			0时为\n
			
	- pull的时候调整的是right，分13个等级（0到12）
			0时为\n
- [Bootstrap 栅格系统的精妙之处](https://segmentfault.com/a/1190000000743553)
	- **CONTAINER:**
		- Container 有两个作用：
			- 在随时可能的宽度变化(响应式)中提供宽度限制。当页面宽度变化，container 的宽度也随之变化。并且其中的 column 的宽度是基于百分比，所以他们的值不需要变化。
			- 提供一个水平方向的 padding，使其内部的内容不会接触到浏览器的边界，大小为15px，就是图片中粉红色的部分，作用会在下面说。
		- 注意，不需要也不应该在 container 中嵌套另一个 container。
		- ![container](http://www.helloerik.com/wp-content/uploads/image-1.png)
	- **ROW**
		- Row 是 column 直接存在的容器，按照文档描述 row 中最多可有12个 column，不过可以通过 nesting 的方式灵活扩展。同时作为都是左浮动的 column 的 wrapper，自带 clearfix 的性质。
		- 同时 row 还有一个很特殊的地方，就是左右各有 －15px 的 margin，就是图片中的蓝色部分。这样也就抵消了上面提到的 container 中15px的 padding
		- 注意：千万记住要把 row 放到 container 的内部，这样才能保证正常。
		- ![container](http://www.helloerik.com/wp-content/uploads/image-2.png)
	- **COLUMN**
		- 每个column 也会有15px的水平方向的 padding，也就是图片中黄色的部分
		- colunmn 只能在 row 中生存，由于 row 的 margin 为－15px，那么位于两边的 column 就碰到了 container 的边界。但是 colunmn 本身又有 15px 的 padding 使得它其中的内容并不会碰到 container，同时 不同column的内容之间就有了30px的槽
		- 注意：一定要把 column 放到 row 里使用。
		- ![container](http://www.helloerik.com/wp-content/uploads/image-3.png)
	- **NESTING**
		- 把上面一系列的 container, row, column 都设置好，就可以通过 nesting 扩展它的栅格系统了，也就是在 column 中直接嵌套 row，而不需要再套一层 container
		- ![container](http://www.helloerik.com/wp-content/uploads/image-5.png)
		- container 和 column 都有15px的 padding ，当 nesting 的时候 column 的作用也相当于 container 了，这样就可以实现任意的嵌套了。
		- ![container](http://www.helloerik.com/wp-content/uploads/image-6.png)
---

### HTML5

-   **attr&prop**
	-	**什么是attribute?**
		-	html的预定义和自定义属性
	-   **什么是property?**
		-	js对象身上的直接属性
	-	**什么是布尔值属性，什么是非布尔值属性**
		-	property所对应的属性值是否是布尔类型
	-	**attribute和property的同步关系**
		-	非布尔值属性
			-	实时同步
		-	布尔值属性
			-	没有动过property
				-	attribute会同步property
				-	property不会同步attribute
			-	动过property
				-	attribute不会同步property
				-	property不会同步attribute
	-	**浏览器认谁，用户操作的是谁**
		-	property
	-	**在jQuery中的体现**
		-	attr()
		-	prop()
	-	**总结**
		-	布尔值属性最好使用prop方法
		-	非布尔值属性attr方法
-	**DOCTYPE和浏览器渲染模式**
	-	DOCTYPE，或者称为 Document Type Declaration（文档类型声明，缩写 DTD）
	-	通常情况下，DOCTYPE 位于一个 HTML 文档的最前面的位置，位于根元素 HTML 的起始标签之前。因为浏览器必须在解析 HTML 文档正文之前就确定当前文档的类型，以决定其需要采用的渲染模式，不同的渲染模式会影响到浏览器对于 CSS 代码甚至 JavaScript 脚本的解析
	-	到目前为止，各浏览器主要包含了三种模式。在 HTML5 草案中，更加明确的规定了模式的定义：
	-	在现代主流浏览器中，其实怪异模式的渲染和标准与几乎标准间没有太大的差别（ie9+ 谷歌 火狐 ...）
	-	ie5.5之前都是ie自己的渲染模式，怪异模式
	-	ie6才开始慢慢支持标准，标准模式，在ie6 中怪异和标准模式的区别最大
	-	ie7 8 9都是基于标准模式升级的，他们理论上存在怪异模式
	-	HTML5提供的<DOCTYPE html>是标准模式，向后兼容的,等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的 标准解析渲染页面
		-	一个不含任何 DOCTYPE 的网页将会以 怪异(quirks) 模式渲染。
-	**DTD**
	-	`<!DOCTYPE html><br>`
		-	当 doctype 信息如上时，表明该页面是遵守了 HTML5 规范的，浏览器会选择 Standards Mode，这种 doctype 是最推荐的一种，我们平时设计页面都应该加上这一个 doctype。
		-	HTML5 不基于 SGML,所以不需要引用 DTD,浏览器内部本身有对标签进行解析渲染验证的模块
	-	`<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">`
		-	当 doctype 如上时，浏览器同样会选择 Standards Mode，虽然和第一种 doctype 有一些区别，但是几乎可以认为是一样的。

	-	`<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">`
		-	当 doctype 如上时，浏览器会选择 Almost Standards Mode，渲染时和标准会有一些区别
		-	当 doctype 缺失的时候，浏览器会选择 Quirks Mode，这是非常不推荐的方式，
		-	当 doctype上面有注释，标签或者空行时，某些浏览器都会认为该页面不具有doctype。
		-	我们应该尽量避免 Quirks Mode，这对一个 web 应用是非常不利的地方。

	-	[每种doctype在浏览器中对应的渲染模式](https://en.wikipedia.org/wiki/Quirks_mode)
-	**新增的语义化标签**
	-	header
	-	footer
	-	section
	-	nav
-	**什么是Html5**
	-	HTML5 是定义 HTML 标准的最新的版本。 该术语表示两个不同的概念：
		-	它是一个新版本的HTML语言，具有新的元素，属性和行为，
		-	它有更大的技术集，允许更多样化和强大的网站和应用程序。
			-	这个集合有时称为HTML5和朋友，通常缩写为HTML5。
	
	-	**HTML5     约等于     HTML + CSS + JS**
		
-	**Html5优势**
	-	跨平台(实际上是跨浏览器):唯一一个通吃PC MAC Iphone Android等主流平台的跨平台语言
	-	快速迭代
	-	降低成本
	-	导流入口多
	-	分发效率高
-	**H5中的根元素**
	-	`<html></html>`
-	**MIME类型:**<br>
	-	
		每当浏览器请求一个页面时，web服务器会在发送实际页面内容之前，先发送一些头信息。
		浏览器需要这些信息来决定如何解析随后的页面内容。最重要的是Content-Type
		比如: Content-Type:text/html
		text/html:即这个页面的"内容类型",或者称为MIME类型。这个头信息将唯一确定某个资源的本质是什么
		也决定了它应该如何被呈现。
		图片也有自己的MIME类型	
			jpg:image/jpeg   
			png:image/png
		js也有自己的MIME类型，css也有自己的MIME类型，
			任何资源都有自己的MIME类型，整个web都依靠MIME类型来运作
	`<meta charset="UTF-8">:`
		告诉浏览器你应该使用哪种编码来解析网页
####   Canvas
-	**canvas基本用法**
	-	**什么是canvas(画布)**
		-	`<canvas>` 是 HTML5 新增的元素，可用于通过使用JavaScript中的脚本来绘制图形
		例如，它可以用于绘制图形，创建动画。`<canvas> `最早由Apple引入WebKit
		我们可以使用`<canvas>`标签来定义一个canvas元素
		-	使用`<canvas>`标签时，建议要成对出现，不要使用闭合的形式。
			-	**canvas元素默认具有高宽**
				-	`width：  300px`<br>
					`height：150px`<br>
	-	**替换内容**
		-	`<canvas>`很容易定义一些替代内容。由于某些较老的浏览器（尤其是IE9之前的IE浏览器）不支持HTML元素"canvas"，但在这些浏览器上你应该要给用户展示些替代内容。这非常简单：我们只需要在`<canvas>`标签中提供替换内容就可以。
			-	支持`<canvas>`的浏览器将会忽略在容器中包含的内容，并且只是正常渲染canvas。
			-	不支持`<canvas>`的浏览器会显示代替内容
	-	**canvas标签的两个属性**
		-	**画布的高宽**
			-	html属性设置width height时只影响画布本身不影画布内容
			-	css属性设置width height时不但会影响画布本身的高宽，还会使画布中的内容等比例缩放（缩放参照于画布默认的尺寸）
		-	**渲染上下文**
			-	`<canvas> `元素只是创造了一个固定大小的画布，要想在它上面去绘制内容，我们需要找到它的渲染上下文
			-	`<canvas>` 元素有一个叫做 `getContext()` 的方法，这个方法是用来获得渲染上下文和它的绘画功能。
			-	`getContext()`只有一个参数，上下文的格式
				-	**获取方式**
				<pre>
				<code>
				var canvas = document.getElementById('box');
				var ctx = canvas.getContext('2d');
				//代码...
				</code>
				</pre>
				  
				  
				-	**检查支持性**
				<pre>
				<code>
				var canvas = document.getElementById('tutorial');
				  if (canvas.getContext){
						var ctx = canvas.getContext('2d');
					} 
				</code>
				</pre>
		-	`<canvas>` 看起来和 `<img> `元素很相像，唯一的不同就是它并没有 src 和 alt 属性。
		-	实际上，`<canvas> `标签只有两个属性—— width和height。这些都是可选的。当没有设置宽度和高度的时候，canvas会初始化宽度为300像素和高度为150像素。
-	注意点
	-	canvas图像的渲染有别于html图像的渲染，
		-	**canvas的渲染极快，不会出现代码覆盖后延迟渲染的问题**
		-	**写canvas代码一定要具有同步思想**
		-	在获取上下文时，一定要先判断画布高宽的问题
		-	**画布默认高宽300*150**
		-	**切记一定要使用html的attribute的形式来定义画布的宽高,通过css形式定义会缩放画布内的图像**
	-	**绘制矩形的问题**
		-	边框宽度的问题，边框宽度是在偏移量上下分别渲染一半，可能会出现小数边框，
		-	**一旦出现小数边框都会向上取整**
		-	**cnvas的api只支持一种图像的直接渲染：矩形，所有其他的图形的绘制都至少需要生成一条路径**
		-	**我们没法使用选择器来选到canvas中的图像**
-	**路径容器**
	-	每次调用路径api时,都会往路径容器里做登记
	-	调用beginPath时,清空整个路径容器
-	**样式容器**
	-	每次调用样式api时,都会往样式容器里做登记
	-	调用save时候,将样式容器里的状态压入样式栈
	-	调用restor时候,将样式栈的栈顶状态弹出到样式样式容器里,进行覆盖
-	**样式栈**
	-	调用save时候,将样式容器里的状态压入样式栈
	-	调用restor时候,将样式栈的栈顶状态弹出到样式样式容器里,进行覆盖
-	**画布api**
	oc.getContext("2d");
	oc.width
	oc.height
-	**上下文api**
	-	ctx.fillRect(x,y,w,h):填充矩形
	-	ctx.strokeRect(x,ymwmh):带边框的矩形
	-	ctx.clearRect(0,0,oc.width,oc.height):**清除整个画布**。**清楚时注意原点的位置**
	-	ctx.fillStyle
		-	设置图形的填充颜色。
	-	ctx.strokeStyle
		-	设置图形轮廓的颜色。
		-	默认情况下，线条和填充颜色都是黑色（CSS 颜色值 #000000）
	-	ctx.lineWidth
		-	置当前绘线的粗细。属性值必须为正数,默认值是1.0
	-	ctx.lineCap	
		-	**指定线段末端的结束方式**。
			-	butt  :线段末端以方形结束。 
			-	round :线段末端以圆形结束
			-	square:线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域
			-	默认值是 butt。
	-	ctx.lineJoin
		-	**设定线条与线条间接合处的样式**（默认是 miter）
			-	round : 圆角
			-	bevel : 斜角
			-	miter : 直角
	-	ctx.moveTo(x,y):将画笔抬起点到x，y处
	-	ctx.lineTo(x,y):将画笔移到x，y处
	-	ctx.rect(x,y,w,h)
	-	ctx.arc(x,y,r,degS,degE,dir)
	-	ctx.arcTo(x1,y1,x2,y2,r):2个坐标，一个半径
		-	结合moveTo(x,y)方法使用，
		-	x,y:起始点
		-	x1,y1：控制点
		-	x2,y2：结束点
	-	ctx.quadraticCurveTo(x1,y1,x2,y2)
		-	结合moveTo(x,y)方法使用，
		-	x,y:起始点
		-	x1,y1：控制点
		-	x2,y2：结束点
		-	必须经过起点和终点
	-	ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3)
		-	结合moveTo(x,y)方法使用，
		-	x,y:起始点
		-	x1,y1：控制点
		-	x2,y2：控制点
		-	x3，y3：结束点
		-	必须经过起点和终点
	-	ctx.fill()
	-	ctx.stroke()
	-	ctx.beginpath():清除路径容器
	-	ctx.closepath():闭合路径
		-	fill自动闭合
		-	stroke需要手动闭合
	-	ctx.save()
		-	将画布当前状态(样式相关 变换相关)压入到样式栈中
	-	ctx.restore()
		-	将样式栈中栈顶的元素弹到样式容器中
		-	图像最终渲染依赖于样式容器
	-	**变换**
		-	ctx.translate(x,y):将原点按当前坐标轴位移x，y个单位
			-	**在canvas中translate是累加的**
		-	ctx.rotate(弧度):
			-	将坐标轴按顺时针方向进行旋转
			-	旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法
			-	**在canvas中rotate是累加的**
		-	ctx.scale(因子):
			-	分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。
			-	放大：放大画布，画布中的一个css像素所占据的物理面积变大，画布中包含的css像素的个数变少,画布中图像所包含的css像素的个数不变
			-	缩小：缩小画布，画布中的一个css像素所占据的物理面积变小，画布中包含的css像素的个数变多,画布中图像所包含的css像素的个数不变
			-	**在canvas中scale是累称的**
-	**画矩形**
	-	ctx.fillRect(x, y, width, height);
		-	充矩形
	-	ctx.strokeRect(x, y, width, height);
		-	描边矩形
	-	clearRect(x, y, width, height)
		-	清除指定矩形区域，让清除部分完全透明，注意原点的位置
-	**绘制圆形**
	-	ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);
		-	startAngle，圆弧的起始点， x轴方向开始计算，单位以弧度表示。
		-	endAngle，圆弧的终点， 单位以弧度表示。
		-	anticlockwise 可选的Boolean值 ，如果为 true，逆时针绘制圆弧，反之，顺时针绘制。
-	**绘制圆弧路径**
	-	ctx.arcTo(x1, y1, x2, y2, radius);
	-	根据当前描点与给定的控制点1连接的直线，和控制点1与控制点2连接的直线，作为使用指定半径的圆的切线，画出两条切线之间的弧线路径
-	**画曲线(贝塞尔)**
	-	**二次贝塞尔**
		-	ctx.quadraticCurveTo(cpx, cpy, x, y)
		-	cp1x,cp1y为一个控制点，x,y为结束点。
		-	起始点为moveto时指定的点
	-	**三次贝塞尔**
		-	bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
		-	绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。
		-	起始点为moveto时指定的点
	-	**引入图片**
		-	ctx.drawImage(img,x,y,w,h)
			-	在canvas中引入图片一定在图片加载完成之后再去操作
				-	即`img.onload=function(){draw(this);}`，具体的操作写在draw方法中
-	**使用背景**
	-	ctx.createPattern(image, repetition);
		-	repetition指定如何重复图像
			-	repeat
			-	repeat-x
			-	repeat-y
			-	no-repeat
	-	使用指定的图像 (CanvasImageSource)创建模式的方法。 它通过repetition参数在指定的方向上重复元图像。此方法返回一个CanvasPattern对象。
		<pre>
		<code>
		window.onload=function(){
			var canvas = document.querySelector("#test");
			if(canvas.getContext){
				var ctx = canvas.getContext("2d");
				
				var img = new Image();
				img.src="tg.png";
				img.onload=function(){
					draw();
				}
				function draw(){
					var pattern = ctx.createPattern(img,"no-repeat")
					ctx.fillStyle=pattern;
					ctx.fillRect(0,0,300,300);
				}
				
			}
		}
		</code>
		</pre>
-	**使用线性渐变**
	-	ctx.createLinearGradient(x0, y0, x1, y1);
	-	使用方法：
	<pre>
	<code>
	window.onload=function(){
		var canvas = document.querySelector("#test");
		if(canvas.getContext){
			var ctx = canvas.getContext("2d");

				var gradient =  ctx.createLinearGradient(0, 0, 200, 200);
				gradient.addColorStop(0,"red");
				gradient.addColorStop(0.5,"yellow");
				gradient.addColorStop(0.7,"pink");
				gradient.addColorStop(1,"green");
				ctx.fillStyle=gradient;
				ctx.fillRect(0,0,300,300);
		}
	}
	</code>
	</pre>
-	**使用径向渐变**
	-	ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
	-	根据参数确定两个圆的坐标以及半径，绘制放射性渐变的方法，
	-	使用方法同线性渐变
-	
-	**绘制文本**
	-	ctx.measureText(text)
		-	被测量文本TextMetrics 对象包含的信息（例如它的宽度）
	-	ctx.fillText(text, x, y [, maxWidth])
		-	在 (x, y)位置填充文本
	-	ctx.strokeText()
		-	在 (x, y)位置给文本描边
	-	ctx.font
		-	设置文本字体
	-	ctx.textAlign
		-	textAlign的值为center时候文本的居中是基于你在fillText的时候所给的x的值，也就是说文本一半在x的左边，一半在x的右边（**可以理解为计算x的位置时从默认文字的左端，改为文字的中心，因此你只需要考虑x的位置即可**）。所以，**如果你想让文本在整个canvas居中，就需要将fillText的x值设置成canvas的宽度的一半。**
	-	ctx.textBaseline
		-	文本的基线
	-	shadowOffsetX = float
		-	阴影水平偏移距离
	-	shadowOffsetY = float
		-	阴影垂直偏移距离
	-	shadowBlur = float
		-	模糊效果程度
	-	shadowColor = color(必需项)
		-	注意:只有设置shadowColor属性值为不透明，阴影才会被绘制
-	**写canvas的时候建议的代码格式套路**
	<pre>
	<code>
	var canvas = document.querySelector("#test");
		if(canvas.getContext){
			var ctx = canvas.getContext("2d");
			//第一个图
			ctx.save();
			//设置样式的代码
			//save  restore成对出现
			ctx.beginPath();
			//设置路径的代码
			ctx.stroke()//或者ctx.fill()
			ctx.restore();
			//第一个图画完了
			//第二个图				
			ctx.save();
			//设置样式的代码
			ctx.beginPath();
			//设置路径的代码
			ctx.stroke()//或者ctx.fill()
			ctx.restore();
			//第二个图画完了
			}
	</code>
	</pre>
-	像素操作
	-	ImageData ctx.getImageData(sx, sy, sw, sh);
		-	用来描述canvas区域隐含的像素数据，这个区域通过矩形表示，起始点为(sx, sy)、宽为sw、高为sh
		-	IndexSizeError
如果高度或者宽度变量为0，则抛出错误。
	-	imageData
		-	width:横向上像素点的个数
		-	height:纵向上像素点的个数
		-	data:数组,存放每一个像素点的rgba信息


-	**实现签名**
-	**实现时钟**

			
-	**音视频**
	-	**音视频标签**

	-	**实现播放器**	
-	**其他新增标签与属性**



